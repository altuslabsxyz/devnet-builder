name: Deploy Devnet

run-name: Devnet-${{ inputs.fork_target }}-${{ github.run_number }}

on:
  workflow_dispatch:
    inputs:
      fork_target:
        description: 'Fork target network (auto-selects stable version)'
        required: true
        type: choice
        options:
          - testnet
          - mainnet
        default: 'testnet'
      validators:
        description: 'Number of validators to create'
        required: true
        type: number
        default: 4
      accounts:
        description: 'Number of dummy accounts to create'
        required: true
        type: number
        default: 10
      account_balance:
        description: 'Balance for each account (optional, e.g., "1000000000000000000000astable,500000000000000000000agusdt")'
        required: false
        type: string
        default: ''
      validator_balance:
        description: 'Balance for each validator (optional, e.g., "1000000000000000000000astable,500000000000000000000agusdt")'
        required: false
        type: string
        default: ''

jobs:
  
  deploy-devnet:
    runs-on: [self-hosted, ubuntu]

    env:
      FORK_TARGET: ${{ inputs.fork_target }}
      VALIDATORS: ${{ inputs.validators }}
      ACCOUNTS: ${{ inputs.accounts }}
      ACCOUNT_BALANCE: ${{ inputs.account_balance }}
      VALIDATOR_BALANCE: ${{ inputs.validator_balance }}
      DEVNET_OUTPUT_DIR: './devnet'
      DEVNET_BASE_DIR: '/data/.devnet'

    steps:
      - name: Checkout stable-devnet repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          fetch-tags: true

      - name: Determine stable tag from fork target
        id: get_tag
        run: |
          # Auto-determine stable tag based on fork target
          if [ "$FORK_TARGET" = "mainnet" ]; then
            TAG="v1.1.0"
          else
            TAG="v1.1.0"
          fi

          echo "Fork target: $FORK_TARGET"
          echo "Auto-selected stable tag: $TAG"
          echo "tag=$TAG" >> $GITHUB_OUTPUT
          echo "STABLE_TAG=$TAG" >> $GITHUB_ENV

      - name: Setup Go
        uses: actions/setup-go@v3
        with:
          go-version: "^1.22"

      - name: Configure Git to use PAT
        run: |
          git config --global url."https://${{ secrets.GH_PAT }}:@github.com/".insteadOf "https://github.com/"
          echo "GOPRIVATE=github.com/stablelabs/*" >> $GITHUB_ENV

      - name: Setup stable repository symbolic link
        id: setup_stable_link
        run: |
          STABLE_LINK_PATH="${GITHUB_WORKSPACE}/stable"
          EXPECTED_TAG="${{ steps.get_tag.outputs.tag }}"
          STABLE_REPO_URL="https://github.com/stablelabs/stable.git"

          echo "Setting up stable repository symbolic link in current repository..."
          echo "Expected tag: $EXPECTED_TAG"
          echo "Stable repository URL: $STABLE_REPO_URL"

          # Remove existing symbolic link if exists
          if [ -L "$STABLE_LINK_PATH" ]; then
            echo "Removing existing symbolic link..."
            rm -f "$STABLE_LINK_PATH"
          fi

          # Remove directory if exists
          if [ -d "$STABLE_LINK_PATH" ]; then
            echo "Warning: stable/ directory exists but is not a symbolic link. Removing..."
            rm -rf "$STABLE_LINK_PATH"
          fi

          # Search for existing stable repository clones
          STABLE_SEARCH_PATHS=(
            "/data/stable"
            "/data/.stable"
            "$HOME/stable"
            "$HOME/.stable"
            "/opt/stable"
            "/tmp/stable-cache"
          )

          STABLE_REPO_PATH=""
          for SEARCH_PATH in "${STABLE_SEARCH_PATHS[@]}"; do
            if [ -d "$SEARCH_PATH/.git" ]; then
              cd "$SEARCH_PATH"
              # Check if it's the correct repository
              REMOTE_URL=$(git config --get remote.origin.url 2>/dev/null || echo "")
              if [[ "$REMOTE_URL" == *"stablelabs/stable"* ]]; then
                STABLE_REPO_PATH="$SEARCH_PATH"
                echo "Found existing stable repository at: $STABLE_REPO_PATH"
                break
              fi
            fi
          done

          # Clone stable repository if not found
          if [ -z "$STABLE_REPO_PATH" ]; then
            echo "Stable repository not found. Cloning..."
            STABLE_REPO_PATH="/tmp/stable-cache"

            if [ -d "$STABLE_REPO_PATH" ]; then
              rm -rf "$STABLE_REPO_PATH"
            fi

            git clone "$STABLE_REPO_URL" "$STABLE_REPO_PATH"
            echo "Cloned stable repository to: $STABLE_REPO_PATH"
          else
            # Fetch latest tags from existing repository
            echo "Fetching latest tags..."
            cd "$STABLE_REPO_PATH"
            git fetch --tags --force
          fi

          # Checkout the correct tag
          cd "$STABLE_REPO_PATH"
          echo "Checking out tag: $EXPECTED_TAG"

          if ! git rev-parse "$EXPECTED_TAG" >/dev/null 2>&1; then
            echo "Error: Tag $EXPECTED_TAG does not exist in stable repository"
            echo "Available tags:"
            git tag | tail -20
            exit 1
          fi

          git checkout "$EXPECTED_TAG"

          # Verify checkout
          CURRENT_TAG=$(git describe --tags --exact-match 2>/dev/null || echo "")
          if [ "$CURRENT_TAG" != "$EXPECTED_TAG" ]; then
            echo "Error: Failed to checkout tag $EXPECTED_TAG (current: $CURRENT_TAG)"
            exit 1
          fi

          echo "Successfully checked out tag: $CURRENT_TAG"

          # Create symbolic link in current repository
          cd "$GITHUB_WORKSPACE"
          ln -sf "$STABLE_REPO_PATH" "$STABLE_LINK_PATH"

          # Verify symbolic link
          if [ ! -L "$STABLE_LINK_PATH" ]; then
            echo "Error: Failed to create symbolic link"
            exit 1
          fi

          LINK_TARGET=$(readlink -f "$STABLE_LINK_PATH")
          echo "Symbolic link created: $STABLE_LINK_PATH -> $LINK_TARGET"

          # Verify the link points to correct version
          cd "$STABLE_LINK_PATH"
          VERIFY_TAG=$(git describe --tags --exact-match 2>/dev/null || echo "")
          echo "Verified stable version: $VERIFY_TAG"

          if [ "$VERIFY_TAG" != "$EXPECTED_TAG" ]; then
            echo "Error: Symbolic link points to wrong version (expected: $EXPECTED_TAG, got: $VERIFY_TAG)"
            exit 1
          fi

          echo "stable_path=$STABLE_LINK_PATH" >> $GITHUB_OUTPUT

      - name: Download stabled binary from release
        id: download_stabled
        run: |
          STABLE_TAG="${{ steps.get_tag.outputs.tag }}"
          STABLE_PATH="${{ steps.setup_stable_link.outputs.stable_path }}"
          GH_TOKEN="${{ secrets.GH_PAT }}"
          FORK_TARGET="${{ inputs.fork_target }}"

          echo "Downloading stabled binary from GitHub release..."
          echo "Tag: $STABLE_TAG"
          echo "Fork target: $FORK_TARGET"
          echo "Stable path: $STABLE_PATH"

          # Create build directory
          mkdir -p "$STABLE_PATH/build"

          # First, get the release information to find the correct asset
          echo "Fetching release information for ${STABLE_TAG}..."
          RELEASE_INFO=$(curl -s -H "Authorization: token $GH_TOKEN" \
            "https://api.github.com/repos/stablelabs/stable/releases/tags/${STABLE_TAG}")

          # Check if release exists
          if echo "$RELEASE_INFO" | jq -e '.message' > /dev/null 2>&1; then
            echo "Error: Release ${STABLE_TAG} not found or inaccessible"
            echo "$RELEASE_INFO" | jq -r '.message'
            exit 1
          fi

          # List available assets
          echo "Available assets:"
          echo "$RELEASE_INFO" | jq -r '.assets[].name'

          # Find the correct asset based on fork_target
          # Support both naming conventions:
          # - v1.0.0: stabled-1.0.0-linux-amd64-mainnet.tar.gz
          # - v0.8.1: stabled-0.8.1-testnet-linux-amd64.tar.gz
          if [ "$FORK_TARGET" = "mainnet" ]; then
            echo "Searching for mainnet asset..."
            ASSET_NAME=$(echo "$RELEASE_INFO" | jq -r '.assets[] | select(.name | test("stabled.*mainnet.*linux.*amd64.*tar\\.gz")) | .name' | head -1)

            if [ -z "$ASSET_NAME" ]; then
              ASSET_NAME=$(echo "$RELEASE_INFO" | jq -r '.assets[] | select(.name | test("stabled.*linux.*amd64.*mainnet.*tar\\.gz")) | .name' | head -1)
            fi
          else
            echo "Searching for testnet asset..."
            ASSET_NAME=$(echo "$RELEASE_INFO" | jq -r '.assets[] | select(.name | test("stabled.*testnet.*linux.*amd64.*tar\\.gz")) | .name' | head -1)

            if [ -z "$ASSET_NAME" ]; then
              ASSET_NAME=$(echo "$RELEASE_INFO" | jq -r '.assets[] | select(.name | test("stabled.*linux.*amd64.*testnet.*tar\\.gz")) | .name' | head -1)
            fi
          fi

          if [ -z "$ASSET_NAME" ]; then
            echo "Error: No stabled binary found for linux-amd64 $FORK_TARGET"
            echo "Available assets:"
            echo "$RELEASE_INFO" | jq -r '.assets[].name'
            exit 1
          fi

          echo "Found asset: $ASSET_NAME"

          # Get the asset download URL
          ASSET_URL=$(echo "$RELEASE_INFO" | jq -r ".assets[] | select(.name == \"$ASSET_NAME\") | .url")

          echo "Downloading from: $ASSET_URL"

          # Download the asset with authentication
          curl -L -H "Authorization: token $GH_TOKEN" \
            -H "Accept: application/octet-stream" \
            -o "$STABLE_PATH/build/$ASSET_NAME" \
            "$ASSET_URL"

          # Extract tar.gz
          echo "Extracting $ASSET_NAME..."
          cd "$STABLE_PATH/build"
          tar -xzf "$ASSET_NAME" -v

          echo "Extracted files:"
          ls -lah

          # Find the stabled binary in extracted files
          echo "Searching for stabled binary..."
          STABLED_BINARY=$(find . -name "stabled" -type f | head -1)

          if [ -z "$STABLED_BINARY" ]; then
            echo "Error: stabled binary not found in extracted files"
            echo "All files in build directory:"
            find . -type f
            exit 1
          fi

          echo "Found stabled at: $STABLED_BINARY"

          # Check file type
          echo "File type:"
          file "$STABLED_BINARY"

          # Move binary to expected location if not already there
          TARGET_PATH="$STABLE_PATH/build/stabled"
          if [ "$STABLED_BINARY" != "./stabled" ] && [ "$STABLED_BINARY" != "stabled" ]; then
            echo "Moving $STABLED_BINARY to $TARGET_PATH"
            mv "$STABLED_BINARY" "$TARGET_PATH"
          else
            echo "Binary already in correct location (./stabled)"
          fi

          # Clean up tar.gz and extracted directories
          echo "Cleaning up..."
          rm -f "$ASSET_NAME"
          find . -mindepth 1 -maxdepth 1 -type d -exec rm -rf {} \;

          # Remove extracted documentation files
          rm -f CHANGELOG.md LICENSE README.md

          # Make binary executable
          chmod +x "$STABLE_PATH/build/stabled"

          # Verify binary
          if [ ! -f "$STABLE_PATH/build/stabled" ]; then
            echo "Error: stabled binary not found at $STABLE_PATH/build/stabled"
            exit 1
          fi

          echo "Binary downloaded, extracted, and verified"
          "$STABLE_PATH/build/stabled" version || echo "Version check skipped"

          echo "stabled_binary=$STABLE_PATH/build/stabled" >> $GITHUB_OUTPUT

      - name: Install decompression tools
        run: |
          echo "Installing snapshot decompression tools..."

          # Update package list
          sudo apt-get update -qq

          # Install lz4 and zstd for snapshot decompression
          sudo apt-get install -y -qq lz4 zstd

          # Verify installations
          echo "Installed versions:"
          lz4 --version || echo "lz4 installation failed"
          zstd --version || echo "zstd installation failed"

          echo "Decompression tools installed successfully"

      - name: Provision and sync target chain
        id: export_genesis
        run: |
          STABLE_PATH="${{ steps.setup_stable_link.outputs.stable_path }}"
          STABLED_BINARY="${{ steps.download_stabled.outputs.stabled_binary }}"
          GENESIS_EXPORT_PATH="${GITHUB_WORKSPACE}/genesis-export.json"

          # Determine target chain-id, RPC endpoint, persistent peers, and snapshot URL based on fork target
          if [ "$FORK_TARGET" = "mainnet" ]; then
            TARGET_CHAIN_ID="stable_988-1"
            TARGET_RPC_ENDPOINT="https://cosmos-rpc-internal.stable.xyz/"
            PERSISTENT_PEERS="39fef24240d80e2cd5bdcbe101298c36f0d83fa1@57.129.53.87:26656"
            SNAPSHOT_URL="https://stable-mainnet-data.s3.amazonaws.com/snapshots/stable_pruned.tar.zst"
          else
            TARGET_CHAIN_ID="stabletestnet_2201-1"
            TARGET_RPC_ENDPOINT="https://cosmos-rpc.testnet.stable.xyz/"
            PERSISTENT_PEERS="128accd3e8ee379bfdf54560c21345451c7048c7@peer1.testnet.stable.xyz:26656,5ed0f977a26ccf290e184e364fb04e268ef16430@peer2.testnet.stable.xyz:26656"
            SNAPSHOT_URL="https://stable-snapshot.s3.eu-central-1.amazonaws.com/snapshot.tar.lz4"
          fi

          echo "=========================================="
          echo "Fork Target: $FORK_TARGET"
          echo "Target Chain ID: $TARGET_CHAIN_ID"
          echo "Target RPC Endpoint: $TARGET_RPC_ENDPOINT"
          echo "Persistent Peers: $PERSISTENT_PEERS"
          echo "Snapshot URL: $SNAPSHOT_URL"
          echo "Using stabled binary: $STABLED_BINARY"
          echo "=========================================="

          # Determine which script to use based on SNAPSHOT_URL
          if [ -n "$SNAPSHOT_URL" ]; then
            echo "=========================================="
            echo "Using SNAPSHOT-BASED provisioning"
            echo "State-sync: DISABLED"
            echo "=========================================="
            SCRIPT_PATH="${GITHUB_WORKSPACE}/scripts/provision-with-snapshot.sh"

            # Make provision script executable
            chmod +x "$SCRIPT_PATH"

            # Build provision command for snapshot
            PROVISION_CMD="$SCRIPT_PATH \
              --chain-id \"$TARGET_CHAIN_ID\" \
              --snapshot-url \"$SNAPSHOT_URL\" \
              --stabled-binary \"$STABLED_BINARY\" \
              --base-dir \"/data\" \
              --output-file \"$GENESIS_EXPORT_PATH\""

            # Add RPC endpoint if provided (for genesis download)
            if [ -n "$TARGET_RPC_ENDPOINT" ]; then
              PROVISION_CMD="$PROVISION_CMD --rpc-endpoint \"$TARGET_RPC_ENDPOINT\""
            fi

            # Add persistent peers
            if [ -n "$PERSISTENT_PEERS" ]; then
              PROVISION_CMD="$PROVISION_CMD --persistent-peers \"$PERSISTENT_PEERS\""
            fi
          else
            echo "=========================================="
            echo "Using STATE-SYNC provisioning (legacy)"
            echo "State-sync: ENABLED"
            echo "=========================================="
            SCRIPT_PATH="${GITHUB_WORKSPACE}/scripts/provision-and-sync.sh"

            # Make provision script executable
            chmod +x "$SCRIPT_PATH"

            # Build provision command for state-sync
            PROVISION_CMD="$SCRIPT_PATH \
              --chain-id \"$TARGET_CHAIN_ID\" \
              --rpc-endpoint \"$TARGET_RPC_ENDPOINT\" \
              --stabled-binary \"$STABLED_BINARY\" \
              --base-dir \"/data\" \
              --output-file \"$GENESIS_EXPORT_PATH\""

            # Add persistent peers
            if [ -n "$PERSISTENT_PEERS" ]; then
              PROVISION_CMD="$PROVISION_CMD --persistent-peers \"$PERSISTENT_PEERS\""
            fi
          fi

          echo ""
          echo "Executing: $PROVISION_CMD"
          echo ""

          # Run provision script
          eval $PROVISION_CMD

          # Verify export
          if [ ! -f "$GENESIS_EXPORT_PATH" ]; then
            echo "Error: Genesis export failed"
            exit 1
          fi

          GENESIS_SIZE=$(stat -f%z "$GENESIS_EXPORT_PATH" 2>/dev/null || stat -c%s "$GENESIS_EXPORT_PATH" 2>/dev/null)
          echo "Genesis exported successfully (size: $GENESIS_SIZE bytes)"

          # Validate JSON
          if ! jq empty "$GENESIS_EXPORT_PATH" 2>/dev/null; then
            echo "Error: Exported genesis is not valid JSON"
            exit 1
          fi

          echo "genesis_file=$GENESIS_EXPORT_PATH" >> $GITHUB_OUTPUT

      - name: Build devnet with devnet-builder
        id: build_devnet
        run: |
          GENESIS_FILE="${{ steps.export_genesis.outputs.genesis_file }}"

          echo "Building devnet using devnet-builder..."
          echo "Genesis file: $GENESIS_FILE"
          echo "Validators: $VALIDATORS"
          echo "Accounts: $ACCOUNTS"
          if [ -n "$ACCOUNT_BALANCE" ]; then
            echo "Account balance: $ACCOUNT_BALANCE"
          else
            echo "Account balance: (using default)"
          fi
          if [ -n "$VALIDATOR_BALANCE" ]; then
            echo "Validator balance: $VALIDATOR_BALANCE"
          else
            echo "Validator balance: (using default)"
          fi
          echo "Devnet Chain ID: $DEVNET_CHAIN_ID"
          echo "Output directory: $DEVNET_OUTPUT_DIR"

          # Build devnet-builder if not exists
          if [ ! -f "./build/devnet-builder" ]; then
            echo "Building devnet-builder..."
            echo "Using stable version: ${{ steps.get_tag.outputs.tag }}"

            # Build devnet-builder with current stable version
            # Note: stable is already checked out to the correct tag in "Setup stable repository symbolic link" step
            cd "$GITHUB_WORKSPACE"

            # Verify stable path
            STABLE_PATH="${{ steps.setup_stable_link.outputs.stable_path }}"
            if [ ! -d "$STABLE_PATH" ]; then
              echo "Error: Stable path not found: $STABLE_PATH"
              exit 1
            fi

            echo "Stable directory: $STABLE_PATH"
            cd "$STABLE_PATH"
            CURRENT_VERSION=$(git describe --tags --exact-match 2>/dev/null || echo "unknown")
            echo "Current stable version: $CURRENT_VERSION"

            # Sync replace directives from stable/go.mod to devnet-builder/go.mod
            echo "Syncing replace directives from stable to devnet-builder..."
            cd "$GITHUB_WORKSPACE"

            # Extract replace directives from stable's go.mod
            STABLE_EVM_REPLACE=$(grep "github.com/cosmos/evm =>" "$STABLE_PATH/go.mod" || echo "")
            STABLE_BFT_REPLACE=$(grep "github.com/cometbft/cometbft =>" "$STABLE_PATH/go.mod" || echo "")
            STABLE_SDK_REPLACE=$(grep "github.com/cosmos/cosmos-sdk =>" "$STABLE_PATH/go.mod" || echo "")
            STABLE_GETH_REPLACE=$(grep "github.com/ethereum/go-ethereum =>" "$STABLE_PATH/go.mod" || echo "")

            echo "Stable replace directives:"
            echo "  EVM: $STABLE_EVM_REPLACE"
            echo "  BFT: $STABLE_BFT_REPLACE"
            echo "  SDK: $STABLE_SDK_REPLACE"
            echo "  GETH: $STABLE_GETH_REPLACE"

            # Update devnet-builder's go.mod with stable's replace directives
            if [ -n "$STABLE_EVM_REPLACE" ]; then
              sed -i.bak "/github.com\/cosmos\/evm =>/c\\	$STABLE_EVM_REPLACE" go.mod
            fi
            if [ -n "$STABLE_BFT_REPLACE" ]; then
              sed -i.bak "/github.com\/cometbft\/cometbft =>/c\\	$STABLE_BFT_REPLACE" go.mod
            fi
            if [ -n "$STABLE_SDK_REPLACE" ]; then
              sed -i.bak "/github.com\/cosmos\/cosmos-sdk =>/c\\	$STABLE_SDK_REPLACE" go.mod
            fi
            if [ -n "$STABLE_GETH_REPLACE" ]; then
              sed -i.bak "/github.com\/ethereum\/go-ethereum =>/c\\	$STABLE_GETH_REPLACE" go.mod
            fi

            rm -f go.mod.bak

            echo "Updated go.mod replace directives"
            grep -A 4 "^replace (" go.mod | head -10

            # Clean go.sum and regenerate
            rm -f go.sum
            GOWORK=off go mod tidy

            # Return to devnet-builder directory and build
            cd "$GITHUB_WORKSPACE"
            make build
          else
            echo "devnet-builder already exists, skipping build"
          fi

          # Build command
          BUILD_CMD="./build/devnet-builder build \"$GENESIS_FILE\" \
            --validators $VALIDATORS \
            --accounts $ACCOUNTS"

          # Add optional balance and stake parameters if provided
          if [ -n "$ACCOUNT_BALANCE" ]; then
            BUILD_CMD="$BUILD_CMD --account-balance \"$ACCOUNT_BALANCE\""
          fi

          if [ -n "$VALIDATOR_BALANCE" ]; then
            BUILD_CMD="$BUILD_CMD --validator-balance \"$VALIDATOR_BALANCE\""
          fi

          # Add output directory
          BUILD_CMD="$BUILD_CMD --output \"$DEVNET_OUTPUT_DIR\""

          echo "Executing: $BUILD_CMD"
          eval $BUILD_CMD

          # Verify devnet creation
          if [ ! -d "$DEVNET_OUTPUT_DIR" ]; then
            echo "Error: Devnet directory not created"
            exit 1
          fi

          echo "Devnet created successfully"
          ls -la "$DEVNET_OUTPUT_DIR"

          # Count created nodes
          NODE_COUNT=$(find "$DEVNET_OUTPUT_DIR" -maxdepth 1 -type d -name "node*" | wc -l)
          echo "Created $NODE_COUNT validator nodes"

          if [ "$NODE_COUNT" -ne "$VALIDATORS" ]; then
            echo "Warning: Expected $VALIDATORS nodes but found $NODE_COUNT"
          fi

          # Extract actual chain-id from genesis
          ACTUAL_CHAIN_ID=$(jq -r '.chain_id' "$DEVNET_OUTPUT_DIR/node0/config/genesis.json")
          echo "Extracted chain-id from genesis: $ACTUAL_CHAIN_ID"
          echo "actual_chain_id=$ACTUAL_CHAIN_ID" >> $GITHUB_OUTPUT

      - name: Upload devnet artifact
        uses: actions/upload-artifact@v4
        with:
          name: devnet-${{ steps.get_tag.outputs.tag }}-${{ github.run_number }}
          path: ${{ env.DEVNET_OUTPUT_DIR }}
          retention-days: 30
          compression-level: 9

      - name: Deploy devnet to system
        id: deploy_devnet
        run: |
          echo "Deploying devnet to $DEVNET_BASE_DIR..."

          # Remove old backup directories (older than 7 days)
          echo "Removing old backup directories (older than 7 days)..."
          DEVNET_PARENT_DIR=$(dirname "$DEVNET_BASE_DIR")
          DEVNET_BASE_NAME=$(basename "$DEVNET_BASE_DIR")
          OLD_BACKUPS=$(sudo find "$DEVNET_PARENT_DIR" -maxdepth 1 -type d -name "${DEVNET_BASE_NAME}_backup_*" -mtime +7 2>/dev/null || true)

          if [ -n "$OLD_BACKUPS" ]; then
            echo "Found old backups to remove:"
            echo "$OLD_BACKUPS"
            echo "$OLD_BACKUPS" | xargs -I {} sudo rm -rf {}
          else
            echo "No old backups found"
          fi

          # Backup existing devnet if exists
          if [ -d "$DEVNET_BASE_DIR" ] && [ "$(ls -A $DEVNET_BASE_DIR 2>/dev/null)" ]; then
            BACKUP_DIR="${DEVNET_BASE_DIR}_backup_$(date +%Y%m%d_%H%M%S)"
            echo "Backing up existing devnet to: $BACKUP_DIR"
            sudo mv "$DEVNET_BASE_DIR" "$BACKUP_DIR"
          fi

          # Create fresh base directory
          echo "Creating fresh devnet directory..."
          sudo mkdir -p "$DEVNET_BASE_DIR"
          sudo chown -R $(whoami):$(whoami) "$DEVNET_BASE_DIR"

          # Copy devnet files to system directory
          echo "Copying devnet files to $DEVNET_BASE_DIR..."
          cp -r "$DEVNET_OUTPUT_DIR"/* "$DEVNET_BASE_DIR/"

          # Verify deployment
          echo "Verifying deployment..."
          ls -la "$DEVNET_BASE_DIR"

          # Count deployed nodes
          NODE_COUNT=$(find "$DEVNET_BASE_DIR" -maxdepth 1 -type d -name "node*" | wc -l)
          echo "Deployed $NODE_COUNT validator nodes to $DEVNET_BASE_DIR"

      - name: Start devnet nodes with systemd
        id: start_nodes
        run: |
          STABLE_PATH="${{ steps.setup_stable_link.outputs.stable_path }}"
          STABLED_BINARY="$STABLE_PATH/build/stabled"
          ACTUAL_CHAIN_ID="${{ steps.build_devnet.outputs.actual_chain_id }}"
          TIMESTAMP=$(date +%Y%m%d_%H%M%S)
          
          echo "Starting devnet nodes with systemd..."
          echo "Using stabled binary: $STABLED_BINARY"
          echo "Chain ID: $ACTUAL_CHAIN_ID"
          echo "Timestamp: $TIMESTAMP"
          
          # Verify stabled binary exists
          if [ ! -f "$STABLED_BINARY" ]; then
            echo "Error: stabled binary not found at $STABLED_BINARY"
            exit 1
          fi
          
          # Make sure stabled is executable
          chmod +x "$STABLED_BINARY"
          
          # Create log directory
          LOG_DIR="$DEVNET_BASE_DIR/logs"
          mkdir -p "$LOG_DIR"
          echo "Log directory: $LOG_DIR"
          
          # Stop all existing devnet services before starting
          echo ""
          echo "Step 0: Stopping all existing devnet services..."

          # Find all devnet-node* services (regardless of current VALIDATORS count)
          EXISTING_SERVICES=$(sudo systemctl list-units --all --type=service --no-legend | grep -E "devnet-node[0-9]+" | awk '{print $1}' || echo "")

          if [ -n "$EXISTING_SERVICES" ]; then
            echo "Found existing devnet services:"
            echo "$EXISTING_SERVICES"
            echo ""

            # Stop and disable each service
            echo "$EXISTING_SERVICES" | while read -r SERVICE_NAME; do
              if [ -n "$SERVICE_NAME" ]; then
                echo "  Stopping and disabling: $SERVICE_NAME"
                sudo systemctl stop "$SERVICE_NAME" --force || true
                sudo systemctl disable "$SERVICE_NAME" || true
              fi
            done

            # Also check for service files in /etc/systemd/system/ and remove them
            echo ""
            echo "Removing service files from /etc/systemd/system/..."
            sudo find /etc/systemd/system/ -name "devnet-node*.service" -type f -exec rm -f {} \; 2>/dev/null || true
            sudo find /etc/systemd/system/ -name "devnet-node*.service.d" -type d -exec rm -rf {} \; 2>/dev/null || true

            # Reload systemd daemon after removing service files
            sudo systemctl daemon-reload
          else
            echo "No existing devnet services found"
          fi

          # Wait for services to fully stop
          sleep 2
          echo "All existing services stopped and cleaned up"


          # Function to find available port
          find_available_port() {
            local start_port=$1
            shift
            local excluded_ports=("$@")
            local port=$start_port
          
            while [ $port -lt $((start_port + 1000)) ]; do
              local is_excluded=false
              for excluded in "${excluded_ports[@]}"; do
                if [ "$port" = "$excluded" ]; then
                  is_excluded=true
                  break
                fi
              done
          
              if [ "$is_excluded" = false ] && ! lsof -i:$port > /dev/null 2>&1; then
                echo $port
                return 0
              fi
              port=$((port + 1))
            done
          
            echo "Error: Could not find available port starting from $start_port" >&2
            exit 1
          }
          
          # Step 1: Configure all validator nodes (but don't start yet)
          echo "Step 1: Configuring all nodes..."

          # Determine which node uses default 266 prefix ports
          # Rule: node2 (index 2) if validators >= 3, otherwise last node
          if [ $VALIDATORS -ge 3 ]; then
            DEFAULT_PORT_NODE=2
          else
            DEFAULT_PORT_NODE=$((VALIDATORS - 1))
          fi

          # Determine the main RPC node (also uses default ports)
          MAIN_RPC_NODE=$DEFAULT_PORT_NODE

          echo "Node with default ports (266 prefix): node${DEFAULT_PORT_NODE}"
          echo "Main RPC node: node${MAIN_RPC_NODE}"
          echo ""

          # Track allocated ports to avoid conflicts
          ALLOCATED_PORTS=(26657 26656 26658)  # Reserve default ports for the designated node

          for i in $(seq 0 $((VALIDATORS - 1))); do
            NODE_NAME="node$i"
            NODE_HOME="$DEVNET_BASE_DIR/$NODE_NAME"
            CONFIG_FILE="$NODE_HOME/config/config.toml"
            APP_CONFIG_FILE="$NODE_HOME/config/app.toml"
          
            echo "Configuring $NODE_NAME..."
          
            # Verify node directory exists
            if [ ! -d "$NODE_HOME" ]; then
              echo "Error: Node directory not found: $NODE_HOME"
              exit 1
            fi

            # Initialize node with stabled (continue even if it fails)
            echo "  Initializing $NODE_NAME with stabled..."
            "$STABLED_BINARY" init "$NODE_NAME" \
              --home "$NODE_HOME" \
              --chain-id "$ACTUAL_CHAIN_ID" || true
          
            echo "  Node initialization completed (or skipped if already initialized)"

            # Configure ports dynamically
            if [ $i -eq $DEFAULT_PORT_NODE ]; then
              # This node keeps default 266 prefix ports (26657, 26656, 26658)
              echo "  Keeping default ports for $NODE_NAME (26657, 26656, 26658)"
              NODE_RPC_PORT=26657
              NODE_P2P_PORT=26656
              NODE_PROXY_PORT=26658
            else
              # Find available ports dynamically for other nodes
              echo "  Finding available ports for $NODE_NAME..."

              # Find RPC port (starting from 26657)
              NODE_RPC_PORT=$(find_available_port 26657 "${ALLOCATED_PORTS[@]}")
              ALLOCATED_PORTS+=($NODE_RPC_PORT)

              # Find P2P port (starting from 26656)
              NODE_P2P_PORT=$(find_available_port 26656 "${ALLOCATED_PORTS[@]}")
              ALLOCATED_PORTS+=($NODE_P2P_PORT)

              # Find Proxy App port (starting from 26658)
              NODE_PROXY_PORT=$(find_available_port 26658 "${ALLOCATED_PORTS[@]}")
              ALLOCATED_PORTS+=($NODE_PROXY_PORT)

              echo "  Assigned ports: RPC=$NODE_RPC_PORT, P2P=$NODE_P2P_PORT, ProxyApp=$NODE_PROXY_PORT"

              # Update config.toml with awk
              cp "$CONFIG_FILE" "${CONFIG_FILE}.bak"
              awk -v rpc_port="$NODE_RPC_PORT" -v p2p_port="$NODE_P2P_PORT" -v proxy_port="$NODE_PROXY_PORT" '
              {
                # Update proxy_app at the beginning of file
                if ($0 ~ /^proxy_app = "tcp:\/\/.*:[0-9]+"/) {
                  print "proxy_app = \"tcp://0.0.0.0:" proxy_port "\""
                  next
                }

                # Track which section we are in
                if ($0 ~ /^\[rpc\]/) {
                  in_rpc = 1
                  in_p2p = 0
                }
                else if ($0 ~ /^\[p2p\]/) {
                  in_rpc = 0
                  in_p2p = 1
                }
                else if ($0 ~ /^\[.*\]/) {
                  in_rpc = 0
                  in_p2p = 0
                }

                # Update RPC laddr
                if (in_rpc && $0 ~ /^laddr = "tcp:\/\//) {
                  print "laddr = \"tcp://0.0.0.0:" rpc_port "\""
                  next
                }

                # Update P2P laddr
                if (in_p2p && $0 ~ /^laddr = "tcp:\/\//) {
                  print "laddr = \"tcp://0.0.0.0:" p2p_port "\""
                  next
                }

                # Print all other lines as-is
                print
              }
              ' "$CONFIG_FILE" > "${CONFIG_FILE}.tmp"
              mv "${CONFIG_FILE}.tmp" "$CONFIG_FILE"
            fi
          
            # Configure app.toml - disable all services except for main RPC node
            cp "$APP_CONFIG_FILE" "${APP_CONFIG_FILE}.bak"

            if [ $i -eq $MAIN_RPC_NODE ]; then
              # Main RPC node: enable all services (API, gRPC, JSON-RPC)
              sed -i.tmp \
              -e 's/enable = false/enable = true/g' \
              -e 's/tcp:\/\/localhost:1317/tcp:\/\/0.0.0.0:1317/g' \
              -e 's/address = "127.0.0.1:8545"/address = "0.0.0.0:8545"/g' \
              -e 's/ws-address = "127.0.0.1:8546"/ws-address = "0.0.0.0:8546"/g' \
              -e 's/api = "eth,net,web3"/api = "eth,txpool,personal,net,debug,web3"/g' \
              -e 's/enabled-unsafe-cors = false/enabled-unsafe-cors = true/g' \
              "$APP_CONFIG_FILE"
              
              sed -i.tmp \
              -e 's/laddr = "tcp:\/\/127.0.0.1:26657"/laddr = "tcp:\/\/0.0.0.0:26657"/g' \
              "$CONFIG_FILE"
              
              rm -f "${APP_CONFIG_FILE}.tmp" "${CONFIG_FILE}.tmp"
          
              echo "  Keeping all services enabled for $NODE_NAME"
            else
              # All other nodes: disable all services
              echo "  Disabling all services for $NODE_NAME"
              sed -i.tmp 's/enable = true/enable = false/g' "$APP_CONFIG_FILE"
              rm -f "${APP_CONFIG_FILE}.tmp"
            fi
            # Configure prometheus to be disabled
            sed -i.tmp \
                -e 's/prometheus = true/prometheus = false/g' \
                "$CONFIG_FILE"

            # Configure consensus parameters
            echo "  Configuring consensus parameters for $NODE_NAME..."
            sed -i.tmp \
                -e '/^\[consensus\]/,/^\[/ {
                  s/^timeout_propose = .*/timeout_propose = "5s"/
                  s/^timeout_propose_delta = .*/timeout_propose_delta = "10ms"/
                  s/^timeout_prevote = .*/timeout_prevote = "50ms"/
                  s/^timeout_prevote_delta = .*/timeout_prevote_delta = "10ms"/
                  s/^timeout_precommit = .*/timeout_precommit = "50ms"/
                  s/^timeout_precommit_delta = .*/timeout_precommit_delta = "10ms"/
                  s/^timeout_commit = .*/timeout_commit = "650ms"/
                }' \
                "$CONFIG_FILE"

            rm -f "${CONFIG_FILE}.tmp"

            echo "  $NODE_NAME configuration completed"
          done
          
          # Step 2: Collect peer information from all nodes
          echo ""
          echo "Step 2: Collecting peer information..."
          PERSISTENT_PEERS_LIST=()
          
          for i in $(seq 0 $((VALIDATORS - 1))); do
            NODE_NAME="node$i"
            NODE_HOME="$DEVNET_BASE_DIR/$NODE_NAME"
            CONFIG_FILE="$NODE_HOME/config/config.toml"
          
            # Get node ID
            NODE_ID=$("$STABLED_BINARY" comet show-node-id --home "$NODE_HOME")
          
            # Extract P2P port from config.toml
            P2P_PORT=$(grep -A 20 "^\[p2p\]" "$CONFIG_FILE" | grep "^laddr" | head -1 | sed 's/.*://; s/".*//')
          
            # Build peer address
            PEER_ADDR="${NODE_ID}@127.0.0.1:${P2P_PORT}"
            PERSISTENT_PEERS_LIST+=("$PEER_ADDR")
          
            echo "  $NODE_NAME: $PEER_ADDR"
          done
          
          # Join all peers with comma
          PERSISTENT_PEERS=$(IFS=,; echo "${PERSISTENT_PEERS_LIST[*]}")
          echo ""
          echo "Collected persistent_peers: $PERSISTENT_PEERS"
          
          # Step 3: Update all nodes with persistent_peers and P2P settings
          echo ""
          echo "Step 3: Updating P2P configuration..."
          for i in $(seq 0 $((VALIDATORS - 1))); do
            NODE_NAME="node$i"
            CONFIG_FILE="$DEVNET_BASE_DIR/$NODE_NAME/config/config.toml"
          
            echo "  Updating $NODE_NAME P2P settings..."
          
            # Update persistent_peers, allow_duplicate_ip, and addr_book_strict
            sed -i.tmp \
              -e "s|^persistent_peers = .*|persistent_peers = \"$PERSISTENT_PEERS\"|" \
              -e "s|^allow_duplicate_ip = .*|allow_duplicate_ip = true|" \
              -e "s|^addr_book_strict = .*|addr_book_strict = false|" \
              "$CONFIG_FILE"
          
            rm -f "${CONFIG_FILE}.tmp"
          done
          
          echo "P2P configuration updated for all nodes"
          
          # Step 4: Create log path helper script
          echo ""
          echo "Step 4: Creating log path helper script..."
          LOG_PATH_SCRIPT="/usr/local/bin/devnet-log-path.sh"
          
          if [ ! -f "$LOG_PATH_SCRIPT" ]; then
            cat <<'LOGSCRIPT' | sudo tee "$LOG_PATH_SCRIPT" >/dev/null
          #!/usr/bin/env bash
          NODE="${1:-unknown}"
          TIMESTAMP=$(date +"%Y%m%d_%H%M%S")
          echo "/data/.devnet/logs/devnet_${NODE}_${TIMESTAMP}.log"
          LOGSCRIPT
          
            sudo chmod +x "$LOG_PATH_SCRIPT"
            echo "  Log path script created: $LOG_PATH_SCRIPT"
          else
            echo "  Log path script already exists: $LOG_PATH_SCRIPT"
          fi
          
          # Step 5: Create and start systemd services for all nodes
          echo ""
          echo "Step 5: Creating systemd services..."
          for i in $(seq 0 $((VALIDATORS - 1))); do
            NODE_NAME="node$i"
            NODE_HOME="$DEVNET_BASE_DIR/$NODE_NAME"
            SERVICE_NAME="devnet-${NODE_NAME}"
            SERVICE_FILE="/etc/systemd/system/${SERVICE_NAME}.service"
            DROPIN_DIR="/etc/systemd/system/${SERVICE_NAME}.service.d"
            DROPIN_LOG="${DROPIN_DIR}/logging.conf"
          
            echo "  Creating service for $NODE_NAME..."
          
            # Create base service file
            cat <<SERVICEEOF | sudo tee "$SERVICE_FILE" >/dev/null
          [Unit]
          Description=Devnet $NODE_NAME daemon
          After=network-online.target
          Wants=network-online.target
          
          [Service]
          User=$(whoami)
          WorkingDirectory=$STABLE_PATH
          # ExecStart is overridden in drop-in
          Restart=always
          RestartSec=3
          LimitNOFILE=65535
          
          [Install]
          WantedBy=multi-user.target
          SERVICEEOF
          
            # Create drop-in directory for logging configuration
            sudo mkdir -p "$DROPIN_DIR"
          
            # Create drop-in file with logging configuration
            cat <<DROPINEOF | sudo tee "$DROPIN_LOG" >/dev/null
          [Service]
          Environment=NO_COLOR=1
          ExecStart=
          ExecStart=/bin/bash -c '\
            LOG=\$(/usr/local/bin/devnet-log-path.sh "${NODE_NAME}"); \
            echo "Using log \$LOG"; \
            exec ${STABLED_BINARY} start --home ${NODE_HOME} --chain-id ${ACTUAL_CHAIN_ID} 2>&1 \
              | sed -u -E "s/\x1B\\[[0-9;]*[A-Za-z]//g" \
              | tee -a "\$LOG"'
          DROPINEOF
          
            echo "    Service file: $SERVICE_FILE"
            echo "    Drop-in file: $DROPIN_LOG"
          done
          
          # Reload systemd daemon
          echo ""
          echo "Reloading systemd daemon..."
          sudo systemctl daemon-reload
          
          # Step 6: Start all services
          echo ""
          echo "Step 6: Starting all services..."
          for i in $(seq 0 $((VALIDATORS - 1))); do
            NODE_NAME="node$i"
            SERVICE_NAME="devnet-${NODE_NAME}"
          
            echo "  Starting $SERVICE_NAME..."
            sudo systemctl start "$SERVICE_NAME"
            sudo systemctl enable "$SERVICE_NAME"
          
            # Wait a moment for the service to start
            sleep 2
          
            # Verify service is running
            if systemctl is-active --quiet "$SERVICE_NAME"; then
              echo "  $SERVICE_NAME started successfully"
            else
              echo "  Warning: Failed to start $SERVICE_NAME"
              sudo systemctl status "$SERVICE_NAME" --no-pager || true
            fi
          done
          
          echo ""
          echo "All nodes configured and started as systemd services"

      - name: Export account private keys
        id: export_private_keys
        run: |
          STABLED_BINARY="${{ steps.download_stabled.outputs.stabled_binary }}"
          ACCOUNTS_DIR="$DEVNET_BASE_DIR/accounts"

          echo "Exporting account private keys..."
          echo "Accounts directory: $ACCOUNTS_DIR"
          echo "Using stabled binary: $STABLED_BINARY"

          # Check if accounts directory exists
          if [ ! -d "$ACCOUNTS_DIR" ]; then
            echo "Warning: Accounts directory not found at $ACCOUNTS_DIR"
            echo "Skipping private key export"
            exit 0
          fi

          echo ""
          echo "=========================================="
          echo "Account Private Keys"
          echo "=========================================="

          # List all keys and export their private keys
          KEYS_JSON=$("$STABLED_BINARY" keys list --home "$ACCOUNTS_DIR" --keyring-backend test --output json 2>/dev/null)

          if [ -z "$KEYS_JSON" ] || [ "$KEYS_JSON" = "[]" ]; then
            echo "No keys found in accounts directory"
            exit 0
          fi

          # Extract key names and export private keys
          echo "$KEYS_JSON" | jq -r '.[].name' | while read -r KEY_NAME; do
            if [ -n "$KEY_NAME" ]; then
              PRIVATE_KEY=$("$STABLED_BINARY" keys unsafe-export-eth-key "$KEY_NAME" \
                --home "$ACCOUNTS_DIR" \
                --keyring-backend test 2>/dev/null)

              if [ -n "$PRIVATE_KEY" ]; then
                echo "\"$KEY_NAME\": \"$PRIVATE_KEY\""
              else
                echo "\"$KEY_NAME\": \"ERROR: Failed to export private key\""
              fi
            fi
          done

          echo "=========================================="
          echo ""

      - name: Verify nodes are running
        id: verify_nodes
        run: |
          echo "Waiting for nodes to start..."
          sleep 10
          
          echo "Verifying systemd services..."
          
          # Check if all services are running
          RUNNING_COUNT=0
          for i in $(seq 0 $((VALIDATORS - 1))); do
            NODE_NAME="node$i"
            SERVICE_NAME="devnet-${NODE_NAME}"
          
            if systemctl is-active --quiet "$SERVICE_NAME"; then
              RUNNING_COUNT=$((RUNNING_COUNT + 1))
              echo "$SERVICE_NAME is running"
            else
              echo "Warning: $SERVICE_NAME is not running"
              sudo systemctl status "$SERVICE_NAME" --no-pager || true
            fi
          done
          
          echo ""
          echo "Summary: $RUNNING_COUNT/$VALIDATORS nodes are running"
          
          if [ "$RUNNING_COUNT" -ne "$VALIDATORS" ]; then
            echo "Warning: Not all nodes are running"
          fi
          
          # Display log file locations
          echo ""
          echo "Log files location: $DEVNET_BASE_DIR/logs/"
          if [ -d "$DEVNET_BASE_DIR/logs" ]; then
            ls -lht "$DEVNET_BASE_DIR/logs/" | head -20
          fi

          # Health check: Wait for main RPC node to be ready
          MAIN_RPC_NODE=$((VALIDATORS - 1))
          echo ""
          echo "=========================================="
          echo "Waiting for main RPC node (node${MAIN_RPC_NODE}) to be ready..."
          echo "=========================================="

          RPC_ENDPOINT="http://localhost:26657/status"
          TIMEOUT_SECONDS=600  # 10 minutes
          POLL_INTERVAL=10     # 10 seconds
          START_TIME=$(date +%s)

          echo "Polling $RPC_ENDPOINT every ${POLL_INTERVAL}s (timeout: ${TIMEOUT_SECONDS}s)"
          echo ""

          while true; do
            CURRENT_TIME=$(date +%s)
            ELAPSED=$((CURRENT_TIME - START_TIME))

            # Check timeout
            if [ $ELAPSED -ge $TIMEOUT_SECONDS ]; then
              echo ""
              echo "ERROR: Timeout reached (${TIMEOUT_SECONDS}s). Node did not become ready in time."
              echo "Last curl attempt failed. Please check the logs:"
              echo "  sudo journalctl -u devnet-node${MAIN_RPC_NODE} -n 100"
              echo "  tail -100 $DEVNET_BASE_DIR/logs/devnet_node${MAIN_RPC_NODE}_*.log"
              exit 1
            fi

            # Try to curl the status endpoint
            echo "[${ELAPSED}s] Checking node status..."
            HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" "$RPC_ENDPOINT" 2>/dev/null || echo "000")

            if [ "$HTTP_CODE" = "200" ]; then
              echo ""
              echo "SUCCESS: Node is ready! (HTTP $HTTP_CODE)"
              echo "Elapsed time: ${ELAPSED}s"

              # Display node status
              echo ""
              echo "Node status:"
              curl -s "$RPC_ENDPOINT" | jq '.' 2>/dev/null || curl -s "$RPC_ENDPOINT"
              echo ""
              break
            else
              echo "  HTTP $HTTP_CODE - Node not ready yet, waiting ${POLL_INTERVAL}s..."
              sleep $POLL_INTERVAL
            fi
          done

          echo "=========================================="
          echo "Node verification completed successfully"
          echo "=========================================="

      - name: Display deployment summary
        id: summary
        run: |
          ACTUAL_CHAIN_ID="${{ steps.build_devnet.outputs.actual_chain_id }}"

          # Determine target chain-id, RPC endpoint, and persistent peers based on fork target
          if [ "$FORK_TARGET" = "mainnet" ]; then
            TARGET_CHAIN_ID="stable_988-1"
            TARGET_RPC_ENDPOINT="https://cosmos-rpc-internal.stable.xyz/"
            PERSISTENT_PEERS="39fef24240d80e2cd5bdcbe101298c36f0d83fa1@57.129.53.87:26656"
          else
            TARGET_CHAIN_ID="stabletestnet_2201-1"
            TARGET_RPC_ENDPOINT="https://cosmos-rpc.testnet.stable.xyz/"
            PERSISTENT_PEERS="128accd3e8ee379bfdf54560c21345451c7048c7@peer1.testnet.stable.xyz:26656,5ed0f977a26ccf290e184e364fb04e268ef16430@peer2.testnet.stable.xyz:26656"
          fi

          echo ""
          echo "=========================================="
          echo "Devnet Deployment Summary"
          echo "=========================================="
          echo "Fork Target: $FORK_TARGET"
          echo "Target Chain ID: $TARGET_CHAIN_ID"
          echo "Target RPC Endpoint: $TARGET_RPC_ENDPOINT"
          echo "Persistent Peers: $PERSISTENT_PEERS"
          echo "Stable Tag: ${{ steps.get_tag.outputs.tag }}"
          echo "Devnet Chain ID: $ACTUAL_CHAIN_ID"
          echo "Validators: $VALIDATORS"
          echo "Accounts: $ACCOUNTS"
          echo "Devnet Directory: $DEVNET_BASE_DIR"
          echo "=========================================="
          echo ""
          echo "Systemd Services:"
          for i in $(seq 0 $((VALIDATORS - 1))); do
            NODE_NAME="node$i"
            SERVICE_NAME="devnet-${NODE_NAME}"
            STATUS=$(systemctl is-active "$SERVICE_NAME" 2>/dev/null || echo "inactive")
            echo "  $SERVICE_NAME: $STATUS"
          done
          echo ""
          echo "Devnet Structure:"
          ls -la "$DEVNET_BASE_DIR"
          echo ""
          echo "Recent Log Files:"
          if [ -d "$DEVNET_BASE_DIR/logs" ]; then
            ls -lht "$DEVNET_BASE_DIR/logs/" | head -10
          fi
          echo ""
          echo "Service Management Commands:"
          echo "  View service status: sudo systemctl status devnet-node0"
          echo "  View logs: sudo journalctl -u devnet-node0 -f"
          echo "  View log files: tail -f $DEVNET_BASE_DIR/logs/devnet_node0_*.log"
          echo "  Stop service: sudo systemctl stop devnet-node0"
          echo "  Start service: sudo systemctl start devnet-node0"
          echo "  Restart service: sudo systemctl restart devnet-node0"
          echo ""
          echo "=========================================="
